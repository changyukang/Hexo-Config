title: 3. Quick Sroting (快速排序)
layout: post
comment: true
date: 2018-08-15 20:36:33
categories: [Programming,Algorithm_and_Data_Structure,Python,First_Bundle_of_Algorithm]
tags: [Python,Algorithm,Data Structure]
keywords: quick sorting
description: About quick sorting
---

## 4.1 递归

**递归**：程序调用自身的编程技巧，可以减少代码量
*例子*：
1. 斐波那契数列: 每一个元素都是其前面两个数之和
$1,1,2,3,5,8,13,21...Fib$
$Fib(n) = Fib(n-1) + Fib(n-2)$

2. 阶乘： $n! = n*(n-1)*(n-2)*...*1$
  $n! = (n-1)! * n$

3. 德罗斯效应
  有很多盒子，每个盒子中又有很多盒子，盒子里面又有很多盒子，在其中一个盒子中有一个 key.

```python
递归伪码：
def look_for_key(box):
  for item in box:      //item 是外层盒子里面的一个盒子
    if item is_box():
      look_for_key(item)
    elif item.is_key():
      print "found key!"
```

**递归缺点**：多次函数调用，占用太多的内存空间
**递归优点**：程序简洁，易于理解

## 4.2 栈与调用栈

承接上节：递归

```python
/*倒计时*/
def countdown(i)
  print i
  countdown(i-1)
  
调用上面递归函数
print countdown(10)
```

**问题**：上面程序没有递归截止条件，所以打印到0后还会继续打印-1，-2 ...，修改为：

```python
/*倒计时*/
def countdown(i)
  print i
  if i<=0:        //截止条件
    return
  else:
    countdown(i-1)
  
调用上面递归函数
print countdown(10)
```

**调用栈**：压入、弹出
存储函数调用关系的栈称为“*调用栈* ”

```python
def greet(name)
  print "hello, " + name"!"
  greet2(name)
  print "getting ready to say bye"
  bye()
  
def greet2(name)
  print "how are you, " +name+"?"
  
def bye()
  print "ok, bye!"
  
//调用上面的函数
greet("Dave")
```

**递归调用栈**: 也是函数调用，只不过调用的都是自身，是递归调用
阶乘：factorial
$f(5) = 5! = 5*4*3*2*1$

```python
def f(x):
  if x = 1:
    return 1
  else:
    return x*f(x-1)
```

|递|归|调|用|栈|
|-|-|-|-|-|-|
|$f(5)$|
|$x=5$|$f(4)$|
||$x=4$|$f(3)$|
|||$x=3$|$f(2)$|
||||$x=2$|$f(1)$|

求 f(5)必须先求 f(4)、f(3)、f(2)、f(1)，所以变量占内存空间较大。
递归使用的就是调用栈。

## 4.3 分而治之

**算法的核心**：
*分治*：分而治之（divide and conquer）
*例子*：土地分割

|长：168m 宽64m|
|-|-|

一个长168m,宽64m 的长方形面积，要求划分成**尽可能大**的**正方形**。
**做法**：直接取长度的一半不可以，因为长是84m，不等于宽64m.所以应该先以短边为基准划分成两个64\*64的正方形和一个40\*64的长方形，然后同样的方式划分这个长方形，依次进行下去。

上面是把这么大一块土地进行分割，就不要整体考虑了，把它分成不同的小部分进行处理。（*感觉这个做分治的思想例子不是很合理，容易理解成递归*）

```python
求和：
arr = [2,4,6]
sum(arr) = 12

def sum(arr)
  total = 0
  for x in arr:
    total += x
  
  return total
```

上面是使用循环的方式进行的，这节讲的是递归，所以下面使用递归的方式进行处理

**基线条件**：
1. 空数组
2. 一个元素的数组

上面的数组就可以这样递归：
sum[2,4,6] = 2 + sum[4,6] = 2 + 4 + sum[6](这里 sum[6]就符合上面的基线条件2了)

## 4.4 快速排序

### 4.4.1 快速排序概述
**快速排序**：优雅

C语言：qsort(quick sort)
基线条件：空数组或者只有一个元素的数组（*这里都是基于数组的排序，基于链表的如何实现呢？*）

```python
def quicksort(arr)
  if len(arr) < 2     //基线条件
    return arr
```

1. 如果是两个元素的数组：
|x|y|
|-|-|
如果 x > y，并且是要求从小到大排序的话，直接两个互换即可。

2. 对于三个元素的数组：
|15|33|10|
|-|-|-|
此时需要分治的思想。假设取15为基准值，那么上面的值可以分成两部分，比15小的放在基准值15的左边，比15大的放在基准值15的右边。这样就把除基准值之外的元素分成两个区了（10）15（33）。假设这两个区都是有序的，那么这整个数组就是有序的了。所以只需要在分别对这两个区的元素做排序即可（同样适用分治的思想）。
.
取基准值为15，一般基准值都取第一个元素的值
quicksort([33,15,10]) = quicksort([10]) + [15] + quicksort([33])


3. 对于四个元素的数组，同样的思路，步骤如下：
  * 选基准值，一般取第一个元素的值
  * 把元素进行分区，小于基准值的放左边，大于基准值的放右边（**分治**）
  * 对这两个区同样进行上面的操作（**递归**）
  
### 4.4.2 快速排序的程序表示法

```python
def quicksort(arr)：
  if len(arr) < 2:    //递归基线条件
    return arr
  else:
    pivot = arr[0]    //选取基准值
    less = []
    greater = []      //这里定义两个数组，表示上面分治说的那两个分区
    
    for i in arr[1:]: //因为选第一个元素为基准值，所以这里从第二个元素开始处理
      if i <= pivot:
        less.append(i)
      else:
        greater.append(i)
    
    //分治后的分区分别再进行快速排序，并将这三个数组连接起来
    return quicksort(less) + [pivot] + quicksort(greater)    
```

### 4.4.3 快速排序的大 O 表示法
一些典型的算法复杂度回顾：
*假设计算机 cpu $1$秒执行 $t = 10$ 次指令, 元素基数是 $n = 100$*。时间复杂度是基于**秒**的，所以**最终时间复杂度的结果应该转化成秒**。n 是100， cpu 1s 执行10次，所以 1s 处理 n/t = 100/10 = 10个元素。下面的大 O 表示法是在1秒1条指令的基础上进行表示的，**也可以理解成1秒处理一个元素**，在 cpu 1s 执行10次的基础上，下面的大 O 表示法应该为：
$O(log_2^n)$ ---> $O(log_2^{n/t})$
$O(n) ---> O(n/t)$
... ...


所以实际上的执行时间为：
|$O(log_2^n)$|$O(n)$|$O(n*log_2^n)$|$O(n^2)$|$O(n!)$|
| - | - | - | - | - |
| $log_2^{100/10} = 3.3s$ | $10s$ | $33s$ | $100s$ |  $42 day$ |

*cpu 实际上一秒执行运算次数太多，为了控制在一秒执行一条，可以在代码中每条执行后加一个 sleep(1)--可以只在关键部分加上这个，比如下面例子中的只在数组处理时才加上这个 sleep. 这样的模型就是1秒执行一条指令的了，可以用|$O(log_2^n)$|$O(n)$|$O(n*log_2^n)$|$O(n^2)$|$O(n!)$|来计算时间复杂度，并且方便代码演示，比如：*

```python
from time import sleep
def print_item(list):
  for i in list:
    sleep(1)
    print i
    
list1 = [1,2,3,4,5]
print_item(list1)

这里，n 是5（数组元素个数）, 经过 sleep（1）后，1s 仅执行一个元素的处理。这个 print 操作的时间复杂度是O(n)，所以处理5个元素的时间应该是：O(n=5) = 5s。运行程序可以看到1秒仅打印一个数据。
```

一般情况下，c*n可以简要记作 n，c 是常数项，忽略不计。这个 c 在 n 很小的时候影响很大，但是当 n 很大时，c 的影响就很小了，可以忽略了。算法复杂度计算时，n 都理解为很大的一个数，所以常数项可以忽略。

除此之外，当 n 比较小时，$O(n)$可能会比$O(log_2^n)$要大，但是当 n 很大，就反过来了，所以时间复杂度是后者，以 n 很大的时候计算出的（这种说法是在带常数项的情况下，比如$0.01n$ 和$0.1log_2^n$,如果 n=5，那么前者是小于后者的，但是当 n=1000000时，前者就大于后者了）。

### 4.4.4 快速排序的平均情况和最坏情况

快速排序：
平均情况：$O(nlog_2^n)$
最坏情况：$O(n^2)$

**最坏情况例子**
|10|9|8|7|6|5|4|3|2|1|
|-|-|-|-|-|-|-|-|-|-|
这样如果要用快速排序从小到大排序，每次取每部分第一个元素为基准值，比如第一次取10，这样分成的两部分为：
|9|8|7|6|5|4|3|2|1|左|10|右|-|-|-|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|

分完后，右边没有元素，只有左边有，这样并没有起到分治的目的。算法复杂度也没有因为分治的处理而减少。因为每次取到的都是最大值，没有起到区分的效果。

但是上面的最差情况，一般不用于算法复杂度的评估，实际上用于算法评估的是平均复杂度，前面提到的典型复杂度都是平均情况。而也不会有人对上面那个已经很有序的数组进行排序操作。
