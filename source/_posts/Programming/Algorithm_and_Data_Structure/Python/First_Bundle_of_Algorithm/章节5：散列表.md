title: 4. Hash Table (散列表)
layout: post
comment: true
date: 2018-08-16 8:21:45
categories: [Programming,Algorithm_and_Data_Structure,Python,First_Bundle_of_Algorithm]
tags: [Python,Algorithm,Data Structure]
keywords: hash table
description: About hash table
---

## 5.1 散列表简介

**散列表**：一种数据结构，与数组和链表不同

散列表的内部机制：实现、冲突和散列函数

性能：例如，超市里的水果价格，如果价格
* 有序：可以使用二分法查找，$O(log_2^n)$
* 无序：使用简单查找$O(n)$，或者排序后再使用二分查找

上面是对于新手来说的，对于有经验的售货员，知道水果就能说出价格，对于她来说，**不需要查找**，时间复杂度是$O(1)$。

前面讲了两种数据结构：数组和链表，其实前面讲的栈也是一种数据结构，但是栈主要用于存储，并不用于查找，所以这里说数据结构，主要还是指数组和链表。但是上面的例子基于数组的数据结构的查找，不是很快，而散列表这种数据结构可以解决这个问题。

## 5.2 散列函数

**函数**：即映射，把输入 x 通过一定方式映射到 输出y

**散列函数**：一种特殊的函数
| x|--->|y|
|-|-|-|
|苹果|--->|4|
|梨子|--->|1|
|桃子|--->|2|
|葡萄|--->|3|
|橘子|--->|5|

这里映射成的都是整数，这个是有目的的。这里的这些整数并不是真正的价格，而是散列表对应的数组的下标。
真正存储价格的是下面的结构，还是一个数组：
|2.2|1.5|3.6|4.9|1.1|3.9|
|-|-|-|-|-|-|
|0|1|2|3|4|5|

通过散列函数查找橘子，得到的结果是5，然后根据5直接取到数组下标为5的元素，得到真正的价格是3.9.

散列函数，每次输入得到的输出都是一样的。

这里散列函数只涉及一个输入对应一个输出，还有多个输入得到一个输出的情况，暂不考虑。
**特殊情况**：
两种商品价格相同：对于一个输入对应一个输出的情况，不同商品对应的索引是不同的，所以即使价格相同，也要在散列表的数组中保留两位，存放这两个相同的价格。对于多个输入可以对应一个输出的情况，数组中就可以只保留一个价格了。

散列表的另一个特点：
开始就**知道数组有多大**，即商品有多少，就可以确定散列函数映射的索引范围，保证散列函数得到的索引不会是无效的。

散列表使得查找无序元素跟从数组中获取某一个下标的元素一样快，都是$O(1)$

## 5.3 python 实现散列表和使用

字典：[key: value]  dict()
**字典**可以理解成是**散列表**进行**封装**之后的结构，封装隐藏了中间散列函数映射成数组索引的过程，所以字典直接通过查找就能直接得到最终的水果价格。

```python
book = dict()           //字典、散列表定义
book["apple"] = 0.67    //散列表插入操作
book["milk"] = 1.49
book["egg"] = 1.49

print book
['apple': 0.67, 'egg': 1.49, 'milk': 1.49]

print book['milk']      //散列表查找
1.49
```
